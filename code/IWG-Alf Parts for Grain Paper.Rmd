---
title: "Grain"
output: html_document
date: "2025-07-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# just loading these in, unsure which exactly are still used
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(reshape2)
library(ggthemes)
library(gapminder)
library(multcomp)
library(emmeans)
library(multcompView)
library(lmerTest)
library(scales)
library(tidyverse)
library(readxl)
library(lme4)
library(gvlma)
library(rstatix)
library(sjPlot)
library(gt)
library(car)
library(Rmisc)
library(nlme)
library(pgirmess)
library(MuMIn)
library(sjPlot)
library(grateful)
library(cowplot)
library(kableExtra)
library(MuMIn)
library(ggpmisc)
library(bestNormalize)
```

# making emmeans functions 
```{r}
# Define a 3 WAY function for year 1 summer
compute_emmeansNXS <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "1", Harvest = "Summer")
  
  return(emm_df)}

# Define a 3 WAY  function for year 1 fall
compute_emmeansNXF <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "1", Harvest = "Fall")
  return(emm_df)}

# Define a 3 WAY  function for year 2 Summer
compute_emmeansNYS <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "2", Harvest = "Summer")
  return(emm_df)}

# Define a 3 WAY function for year 2 Fall
compute_emmeansNYF <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "2", Harvest = "Fall")
  return(emm_df)}

# Define a 3 WAY function for year 3 summer
compute_emmeansNZS <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "3", Harvest = "Summer")
  
  return(emm_df)}

# Define a 3 WAY  function for year 3 fall
compute_emmeansNZF <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P*CROP, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "3", Harvest = "Fall")
  return(emm_df)}



# Define a NP function for year 1 summer
compute_emmeansNXS2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "1", Harvest = "Summer")
  return(emm_df)}

# Define a NP  function for year 1 fall
compute_emmeansNXF2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "1", Harvest = "Fall")
  return(emm_df)}

# Define a NP  function for year 2 Summer
compute_emmeansNYS2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "2", Harvest = "Summer")
  return(emm_df)}

# Define a NP function for year 2 Fall
compute_emmeansNYF2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "2", Harvest = "Fall")
  return(emm_df)}

# Define a NP function for year 3 summer
compute_emmeansNZS2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "3", Harvest = "Summer")
  return(emm_df)}

# Define a NP  function for year 3 fall
compute_emmeansNZF2 <- function(model_name) {
  N_levels <- c(0, 40, 80, 120, 160)
  # Get the model object using the provided name
  mod <- get(model_name)
  # Compute estimated marginal means
  emm <- emmeans(mod, specs = ~ N*P, at = list(N = N_levels))
  emm <- update(emm, type = "response")
  # Summarize the results
  summary_emm <- summary(emm)
  # Convert to data frame
  emm_df <- as.data.frame(summary_emm)
  # Add additional columns
  emm_df <- emm_df %>%
    mutate(Year = "3", Harvest = "Fall")
  return(emm_df)}
```

### Estimation of Dehulled Grain Yield

The IWG grain threshability visibly varied by site, and not all grains were fully dehulled, so it was deemed necessary to estimate the true mass of dehulled grain in order to prevent poorly threshed plots from being incorrectly represented as higher yielding. To correct for this, 3-gram samples were taken from each plot’s grain yield. These samples were weighed and imaged, and the images were analyzed using the software ilastik, which visually estimated the proportion of grain still in the hull, naked grain, grain still in the spikelet, and empty hulls and spikelets. The resulting proportions were used to create an estimated dehulled grain weight for the sample, which was then extrapolated to derive an adjusted dehulled grain yield for each experimental plot (Altendorf et al., 2021)

Adjusted plot grain yield= (estimated dehulled sample weight/ sample weight)*(plot grain yield weight) 

### Land Equivalent Ratio (LER)

Land Equivalent Ratio (LER) was calculated to compare the performance of intercrops to that of monocultures... Indicates a relative total forage yield advantage for intercropped plots if the TLER is greater than 1(Mead & Willey, 1980). 

Total LER: TLER= LA+LB= YA/SA + YB/SB
where LA and LB are the partial land equivalent ratio (PLER) for the individual crops. YA and YB are the yields of an individual crop within the intercropped plot, and SA and SB are the yields of an individual crop within a monoculture plot (Mead & Willey, 1980). 

Proportional LER (PrLER) was calculated for each species’ biomass yield to determine each species’ relative contribution to the total LER (Oyejola & Mead, 1982). PLERs can be compared to determine competitive effects between the species in intercrop... A PLER greater than 0.5 indicates a relative yield advantage for a single crop in intercrop compared to its yield at the same seeding rate in monoculture. The proportional partial land equivalent ratio (PrPLER) is the proportion of component crop A to the TLER and can be used to understand how much each intercropped crop contributes to the TLER. 

Proportional LER: PrPLER= LA/TLER
where LA is the partial land equivalent ratio (PLER) for an individual crops and TLER is the total land equivalent ratio for an intercropped plot. 


TLER, PLER, and PrLER were calculated using plots of the same N rate to allow for comparison in the performance of the intercropped system at different N rates (Oyejola & Mead, 1982). TLER and PrLER could not be calculated for grain yields, as IWG only represented one grain-bearing crop in the intercrop, but PLER was calculated for grain yield to allow for comparison between N rates

### Effects and interactions of N rate (N), cropping system (CROP), and environment (E)

Log-linear mixed-effects models with replication as a random effect (ϵ) 
log(Response variable) ~ N*E*C + ϵ
Models for each year-harvest ( Year 1 Summer, Year 1 Fall, Year 2 Summer, Year 2 Fall, Year 3 Summer, Year 3 Fall) as Summer and Fall harvests were expected to have large differences in yield, and so that the change in response variables between years could be easily captured and compared.

Response variables: Yields
- Grain yield
Response variables: LER
- PLER of grain 
- Grain Relative Yield (RY)
Cropping system (C) was not included as a fixed effect for LER, as LER values are calculated as a ratio of yield in intercropping to yield in monoculture.

Analysis of covariance (ANCOVA) was used to determine significant differences (P<0.05) between independent variables and their interactions. Estimated marginal means (EMMs) were calculated and pairwise comparisons were used to understand and rank results between independent variables. 

### Data prep for analysis 

```{r}
data<-read.csv('data/MasterDataSpreadsheet.csv')
```
# Rows to remove due to missing data
NY 208 s22 missing alfalfa 
MN 1122 s23 missing grain 
```{r}
# 2022 Summer NY 208 is the first row in the data table
data <- data[-1, ] # 2022 Summer NY 208
# then the new row 1 becomes the next row needing to be taken out
data <- data[-1, ] # 2023 Summer MN 1122
```
# Rename variables to match models 
```{r}
data2 <- data |> 
  separate_wider_delim(Crop, delim = " + ", 
                       names = c("first_value", "second_value"), 
                       too_few = "align_start") |> 
  mutate(C = if_else(is.na(second_value), "monoculture", "intercrop")) |> 
  mutate(CROP = case_when(
    Intercropped == "y" ~ "Intercropped",  # If intercrop is "y", set CROP to intercrop
    Monocrop == "y" & ALF == "y" ~ "Mono_ALF",  # If monoculture is "y" and alfalfa is "y", set CROP to alfalfa
    Monocrop == "y" & IWG == "y" ~ "Mono_IWG",  # If monoculture is "y" and iwg is "y", set CROP to iwg
    Monocrop == "y" ~ "NA",  # If monoculture is "y" and neither alfalfa nor iwg is "y", set CROP to NA
    TRUE ~ NA_character_  # If no condition matches, assign NA
  ))

V<-data2$first_value #Variety (IWG, Shockwave, Higest, WL)
data2$V<-as.factor(V)
N<-data2$NRate # Nitrogen Rate (0, 40, 80, 120, 160)
data2$N<-as.numeric(N)
P<-data2$Location # Location ("MN", "NY", "WI", "KS")
data2$P<-as.factor(P)
data2$Rep<-as.factor(data2$Rep) # (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
data2$C<-as.factor(data2$C) # Crop (intercrop, monoculture)
data2$CROP <- as.factor(data2$CROP) # Crop (intercrop, monoculture_IWG, monoculture_Alfalfa)
```

# Grain conversion

```{r}
#need to calculate the fractions 
# data points from imaging giving proportionss
# for yr 1 and 2 there are columns with plot individual info for this
#hull fraction 
data2$hullNHd<-data2$hull_N/(data2$hull_N+data2$nkd_N+data2$spklt_N)
#naked seed fraction 
data2$NdkNHd<-data2$nkd_N/(data2$hull_N+data2$nkd_N+data2$spklt_N)
#spiklet fraction 
data2$SpkltNHd <- ifelse(data2$spklt_N == 0, 0, data2$spklt_N / (data2$hull_N + data2$nkd_N + data2$spklt_N))

#IGNORE (Lee's equation)
# converted grain weight using proportion information and his calibration values
#then can just plug and chug into this equation 
#data2$YldHdDH <- (1.26975580047546E-03) + (0.897057684933234 * data2$image_sample_wt_g) - ((1.07961789616701E-05) * data2$hullNHd * data2$hull_A) + ((4.61501772182347E-06) * data2$NdkNHd * data2$nkd_A) - ((2.00025159218368E-05) * ifelse(is.nan(data2$SpkltNHd), 0, data2$SpkltNHd) * ifelse(is.nan(data2$spklt_A), 0, data2$spklt_A))

#new equation from Lee
# converted grain wieghts 
data2$WhSamDH = (0.905045351733363*data2$image_sample_wt_g)-((1.10627799960595E-05)*data2$hullNHd*data2$hull_A)+((4.10249606987368E-06)*data2$NdkNHd*data2$nkd_A)-((2.01262650442053E-05)* ifelse(is.nan(data2$SpkltNHd), 0, data2$SpkltNHd) * ifelse(is.nan(data2$spklt_A), 0, data2$spklt_A)) 


#fix below to create the right proportion and save it  
#samples sent for imaging were a subset, so have to apply the conversion factor to the subsample, need to calculate up to the whole plot samples
data2$G<-((data2$WhSamDH)/(data2$image_sample_wt_g))*(data2$PlotThreshedGrainKgHa)


# Year 3 adjustments 
# need to have naked seed weights to match the adjustments made in yr 1 and yr 2
# NY yr3 was hand threshed, so looks clean as is. No need for adjustments or dehulling
# KS and MN sending to NY to dehull
## weigh a subset of these after they are threshed. then clean that subset. Find the r^2 and if good (~80) then use to estimate a clean weight for the rest of the samples
# WI unknown


```

# Making things numeric as needed 
```{r}
data2$G<-as.numeric(data2$G)
data2$PlotIWGDryKgHa<-as.numeric(data2$PlotIWGDryKgHa)
data2$PlotAlfDryKgHa<-as.numeric(data2$PlotAlfDryKgHa)
data2$PlotTotForageKgHa<-as.numeric(data2$PlotTotForageKgHa)
data2$IWGCP<-as.numeric(data2$IWGCP)
data2$IWGdNDF48<-as.numeric(data2$IWGdNDF48)
data2$IWGLignin<-as.numeric(data2$IWGLignin)
data2$ALFCP<-as.numeric(data2$ALFCP)
data2$ALFdNDF48<-as.numeric(data2$ALFdNDF48)
data2$ALFLignin<-as.numeric(data2$ALFLignin)
data2$ALFADF<-as.numeric(data2$ALFADF)
data2$IWGADF<-as.numeric(data2$IWGADF)
data2$ALFaNDF<-as.numeric(data2$ALFaNDF)
custom_letters <- c("a", "b", "c", "d", "e", "f", "g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z")  # Customize the letters as needed
```
# Nrate data isolation
```{r}
#Just shockwave 
Nd<-data2[data2$first_value != "WL" & data2$first_value != "Higest" ,]

Nd <- Nd %>%
  mutate(CROP = case_when(
    `Crop1` == "Shockwave" ~ "monoA",
    `Crop1` == "IWG" ~ "monoI",
    `Crop1` == "Shockwave + IWG" ~ "inter",
    TRUE ~ NA_character_  # Handle other cases if any
  ))

# MN 2024 has some Filler plots which get the NA character, but code later in this script dosn't like it. 
# So removing these here
Nd <- Nd %>%
  filter(!is.na(CROP))
```

```{r}
#Year
NdX<-Nd[Nd$YearCode == "X",]
NdY<-Nd[Nd$YearCode == "Y",]
NdZ<-Nd[Nd$YearCode == "Z",]

#REMOVE this once you get the corrected year 2 grain values in 
NdY$G<-NdY$PlotThreshedGrainKgHa

#Harvest 
NdXS<-NdX[NdX$Harvest == "Summer",]
NdXF<-NdX[NdX$Harvest == "Fall",]

NdYS<-NdY[NdY$Harvest == "Summer",]
NdYF<-NdY[NdY$Harvest == "Fall",]

NdZS<-NdZ[NdZ$Harvest == "Summer",]
NdZF<-NdZ[NdZ$Harvest == "Fall",]

#IWG vs ALF 
NdXSI<-NdXS[NdXS$Crop1 != "Shockwave",]
NdXSA<-NdXS[NdXS$Crop1 != "IWG",]

NdXFI<-NdXF[NdXF$Crop1 != "Shockwave",]
NdXFA<-NdXF[NdXF$Crop1 != "IWG",]

NdYSI<-NdYS[NdYS$Crop1 != "Shockwave" ,]
NdYSA<-NdYS[NdYS$Crop1 != "IWG",]

NdYFI<-NdYF[NdYF$Crop1 != "Shockwave",]
NdYFA<-NdYF[NdYF$Crop1 != "IWG",]

NdZSI<-NdZS[NdZS$Crop1 != "Shockwave" ,]
NdZSA<-NdZS[NdZS$Crop1 != "IWG",]

NdZFI<-NdZF[NdZF$Crop1 != "Shockwave",]
NdZFA<-NdZF[NdZF$Crop1 != "IWG",]
```

### Analysis for the paper

## Grain Yield 

* Table (Grain yield significance of variables and interactions for each model): Grain anovas 

* Figure (Grain yield response to nitrogen rate (N-Rate) and site by harvest) : Grain Figures Redo N:E

* Figure (Grain yield response to cropping system and site by harvest) : combined grain year 1 and 2 plots E:C

# Grain anovas 

```{r}
#adding year 1 mn grain to the G column because they were actually dehulled instead of imaged for using the equation
NdXSInoMN<-NdXSI[NdXSI$Location != "MN",]
NdXSIMN<-NdXSI[NdXSI$Location == "MN",]
NdXSIMN$G<-NdXSIMN$X2023MNGrainDeHulledKgHa
NdXSIG<-rbind(NdXSInoMN, NdXSIMN)
```

#Grain year 1 (all locations)
```{r}
#REMOVE PLOT MIA MNXS plot 1122 is removed because of missing grain
#NdXSIG<-NdXSIG[-117,]
modNXG<-lmer(G~N*P*CROP + (1|Rep), data=NdXSIG)
anova(modNXG)
#Check Assumptions
NXG_resid<-resid(modNXG)
qqnorm(NXG_resid)
qqline(NXG_resid)
plot(modNXG)
#check assumptions logtransform
modNXG1<-lmer(log(G)~N*P*CROP + (1|Rep), data=NdXSIG)
summary(modNXG1)
anova(modNXG1)
NXG_resid1<-resid(modNXG1)
qqnorm(NXG_resid1)
qqline(NXG_resid1)
plot(modNXG1)


monoIformean<-NdXSIG[NdXSIG$C == 'monoculture',]
mean(monoIformean$G)
Iformean<-NdXSIG[NdXSIG$C == 'intercrop',]
mean(Iformean$G)

#Plot raw data with predicted values regression line
NdXSIG$predicted <- predict(modNXG1, newdata = NdXSIG, re.form = NA)
plotty<-ggplot(NdXSIG, aes(x = N, y = G, color = C, group = C)) +
geom_point()+
facet_wrap(~P, scales = "free_y", ncol = 2)+ #make it by location 
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
labs(x = "N-Rate (Kg/ha)", y = "Grain Yield (Kg/ha)") +  # Label the axes
geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values 
ylim(0, 1700)+ #set y axis scale 
scale_color_discrete(name = "Cropping System")  #legend for colors
# save figures/grain_Nrate_yr1.jpeg


#Threeway means
NXG1emm <- compute_emmeansNXS("modNXG1")
# Perform pairwise comparisons
pairwise_results <- pairwise.t.test(NdXSIG$G, NdXSIG$P, 
                                    p.adjust.method = "bonferroni")

#Pairwise P:C
NXGemmsPC <- emmeans(modNXG1, ~ P*CROP, type = "response") # Obtain estimated marginal means (excluding N)
cld_dataNXGPC <- cld(NXGemmsPC, Letters=custom_letters) # Create compact letter display
cld_dataNXGPC$response <- format(cld_dataNXGPC$response, digits = 5)
cld_dataNXGPC<- cld_dataNXGPC %>%
  select(P, CROP, response, .group)
colnames(cld_dataNXGPC) <- c("Site","Cropping System","Grain Yield (kg ha-1)", "Group")
cld_dataNXGPC  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise P
emmsP <- emmeans(modNXG1, ~ P, type = "response") # Obtain estimated marginal means (excluding N)
pairwise_comparisons <- cld(emmsP, Letters=custom_letters) #pairwise comparison
#Pairwise C
emmsCXG <- emmeans(modNXG1, ~ CROP, type = "response") # Obtain estimated marginal means (excluding N)
cld_dataNXGC <- cld(emmsCXG, Letters=custom_letters) # Create compact letter display
#Pairwise N (I could theoreticlaly delete all pairwise N because its all incorrect apparently after defense...)
N_levels <- c(0, 40, 80, 120, 160)
emmsN <- emmeans(modNXG1, specs = ~ N, at = list(N = N_levels), type = "response")
cld_dataNXGN <- cld(emmsN, Letters=custom_letters) # Create compact letter display
#Pairwise N:P
N_levels <- c(0, 40, 80, 120, 160)
emmsNP <- emmeans(modNXG1, specs = ~ N*P, at = list(N = N_levels), type = "response")
cld_dataNXGNP <- cld(emmsNP, Letters=custom_letters) # Create compact letter display
cld_dataNXGNP$response <- format(cld_dataNXGNP$response, digits = 5)
rownames(cld_dataNXGNP) <- NULL
cld_dataNXGNP<- cld_dataNXGNP %>%
  select(N,P, response, .group)
colnames(cld_dataNXGNP) <- c("N","Site","Grain Yield (kg ha-1)", "Group")
cld_dataNXGNP  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)


#This gives us the slope for each interactions as well as a P value indicating significance level for that slope
emtrends(modNXG1,~ P*CROP, var= "N", infer=TRUE)
emtrends(modNXG1,~ P, var= "N", infer=TRUE)
emtrends(modNXG1,~ CROP, var= "N", infer=TRUE)
summary(modNXG1)


#try to get R2 for the model (not helpful for individual interactions..?)
r2 <- r.squaredGLMM(modNXG1)
r2_interaction <- r.squaredGLMM(modNXG1, which = "conditional", type = "marginal", subset = "interaction")

#try to add R2 and CI to plots (more helpful for individual interactions? or just Threeway?)
NdXSIG$predicted <- predict(modNXG1, newdata = NdXSIG, re.form = NA)
# Predict values and calculate standard errors
pred_ci <- predict(modNXG1, newdata = NdXSIG, re.form = NA, type = "response", se.fit = TRUE)
# Calculate lower and upper confidence interval bounds for fixed effects
lower_ci <- pred_ci$fit - 1.96 * pred_ci$se.fit  # Assuming a 95% confidence interval
upper_ci <- pred_ci$fit + 1.96 * pred_ci$se.fit
# Add confidence interval bounds for fixed effects to the dataframe
NdXSIG$lower_ci_fixed <- lower_ci
NdXSIG$upper_ci_fixed <- upper_ci
ggplot(NdXSIG, aes(x = N, y = G, color = CROP, group = CROP)) +
geom_point()+
geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values
geom_line(aes(N, exp(lower_ci_fixed)))+
geom_line(aes(N, exp(upper_ci_fixed)))+
geom_ribbon(aes(ymin = exp(lower_ci_fixed), ymax = exp(upper_ci_fixed), fill = CROP), alpha = 0.2) +  # Confidence interval shading
facet_wrap(~P, scales = "free_y", ncol = 2)+ #make it by location 
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
labs(x = "N-Rate (Kg/ha)", y = "Grain Yield (Kg/ha)") +  # Label the axes
ylim(0, 1700)+ #set y axis scale 
scale_color_discrete(name = "Cropping System")+  #legend for colors
stat_poly_eq(use_label(c("eq", "R2"))) #add equation and R2 to plot
# save figures/grain_Nrate_r2_yr1.jpeg

```

#Grain year 2 (all locations)

```{r}
#linear 
modNYGadj<-lmer(G~N*P*CROP + (1|Rep), data=NdYSI)
anova(modNYGadj)
#Check Assumptions
NYGadj_resid<-resid(modNYGadj)
qqnorm(NYGadj_resid)
qqline(NYGadj_resid)
plot(modNYGadj)
#check assumptions log-transform
modNYGadj1<-lmer(log(G)~N*P*CROP + (1|Rep), data=NdYSI)
anova(modNYGadj1)
summary(modNYGadj1)
NYGadj_resid1<-resid(modNYGadj1)
qqnorm(NYGadj_resid1)
qqline(NYGadj_resid1)
plot(modNYGadj1)

monoIformean2<-NdYSI[NdYSI$C == 'monoculture',]
mean(monoIformean2$G)
Iformean2<-NdYSI[NdYSI$C == 'intercrop',]
mean(Iformean2$G)


#plot year 2 adjusted
NdYSI$predicted <- predict(modNYGadj1, newdata = NdYSI, re.form = NA)
ggplot(NdYSI, aes(x = N, y = G, color = CROP, group= CROP)) +
    geom_point() + 
  geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values
  labs(x = "N-Rate (Kg/ha)", y = "Grain Yield (Kg/ha)") +  # Label the axes
  ggtitle("Relationship between Grain Yield and Nrate") +  # Add a title
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
  ylim(0, 1200) +
  facet_wrap(~P, scales = "free_y",ncol=2)+ #make it by location (remove to make it across locations)
  scale_color_discrete(name = "Cropping System")  #legend for colors
# save grain_Nrate_yr2

#three way emmeans to compare ranks of adjusted and unadjusted
N_levels <- c(0, 40, 80, 120, 160)
emmsNGadjNPC <- emmeans(modNYGadj1, specs= ~ N*P*CROP, at= list(N = N_levels), type= "response")
cld_dataNYGadjNPC <- cld(emmsNGadjNPC, Letters=custom_letters)
cld_dataNYGadjNPC

#Pairwise done based on adjusted year 2 values!!!
#Pairwise P:C
emmsPC <- emmeans(modNYGadj1, ~ P*CROP, type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNYGadjPC <- cld(emmsPC, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjPC) # Print or view the compact letter display table
cld_dataNYGadjPC$response <- format(cld_dataNYGadjPC$response, digits = 5)
rownames(cld_dataNYGadjPC) <- NULL
cld_dataNYGadjPC<- cld_dataNYGadjPC %>%
  select(P, CROP, response, .group)
colnames(cld_dataNYGadjPC) <- c("Site","Cropping System","Grain Yield (kg ha-1)", "Group")
cld_dataNYGadjPC  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise N:P
N_levels <- c(0, 40, 80, 120, 160)
emmsNP <- emmeans(modNYGadj1, ~ N*P,at= list(N = N_levels), type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNYGadjNP <- cld(emmsNP, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjNP) # Print or view the compact letter display table
cld_dataNYGadjNP$response <- format(cld_dataNYGadjNP$response, digits = 5)
rownames(cld_dataNYGadjNP) <- NULL
cld_dataNYGadjNP<- cld_dataNYGadjNP %>%
  select(N,P, response, .group)
colnames(cld_dataNYGadjNP) <- c("N","Site","Grain Yield (kg ha-1)", "Group")
cld_dataNYGadjNP  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise P
emmsP <- emmeans(modNYGadj1, ~ P,type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNYGadjP <- cld(emmsP, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjP) # Print or view the compact letter display table
#Pairwise N
N_levels <- c(0, 40, 80, 120, 160)
emmsCYGadj <- emmeans(modNYGadj1, specs= ~ N, at= list(N = N_levels), type= "response" ) # Obtain estimated marginal means (excluding N)
cld_dataNYGadjC <- cld(emmsCYGadj, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjC) # Print or view the compact letter display table


#This gives us the slope for each interactions as well as a P value indicating significance level for that slope
#emtrends(modNYGadj1,~ P*C, var= "N", infer=TRUE)
emtrends(modNYGadj1,~ P, var= "N", infer=TRUE)
#emtrends(modNYGadj1,~ C, var= "N", infer=TRUE)
summary(modNYGadj1)

emtrends_result<-emtrends(modNYGadj1,~ P, var= "N", infer=TRUE)
  emtrends_df <- as.data.frame(emtrends_result)
  desired_order_P <- c("MN", "NY", "KS", "WI")
  emtrends_df$P <- factor(emtrends_df$P, levels = desired_order_P)
emmeans_results<-emmeans(modNYGadj1, ~P, at=list(N=0))
emmeans_df <- as.data.frame(emmeans_results)
merged_df <- emtrends_df %>%
  inner_join(emmeans_df, by = c("P")) %>%
  select(P, emmean, N.trend, SE.x)
#view(merged_df)
merged_df$P <- factor(merged_df$P, levels = c("MN", "NY", "KS", "WI"))  # Preferred order for P
# Create a new data frame with the calculated column
new_df <- merged_df %>%
  mutate(equation = sprintf("=%.2f*e(%.4fN)", exp(emmean), N.trend),  SE.x = sprintf("%.4f", SE.x),  percent_change = sprintf("%.2f%%", (exp(N.trend) - 1) * 100))%>%
  select(-emmean, -N.trend)
sorted_df <- new_df %>%
  arrange(P)
view(sorted_df)
#write.csv(sorted_df, "data/Nrate_esteff_grain_yr2.csv")
```

#Grain year 3 (all locations)

```{r}
#linear (year 3, unadjusted)
modNZG<-lmer(PlotThreshedGrainKgHa~N*P*CROP + (1|Rep), data=NdZSI)
anova(modNZG)
#Check Assumptions
NZG_resid<-resid(modNZG)
qqnorm(NZG_resid)
qqline(NZG_resid)
plot(modNZG)
abline(h = 0, col="red")
#check assumptions log-transform
modNZG1<-lmer(log(PlotThreshedGrainKgHa)~N*P*CROP + (1|Rep), data=NdZSI)
anova(modNZG1)
NZG_resid1<-resid(modNZG1)
qqnorm(NZG_resid1)
qqline(NZG_resid1)
plot(modNZG1)

monoIformean2<-NdZSI[NdZSI$C == 'monoculture',]
#mean(monoIformean2$GAdjY)
mean(monoIformean2$PlotThreshedGrainKgHa)
Iformean2<-NdZSI[NdZSI$C == 'intercrop',]
#mean(Iformean2$GAdjY)
mean(Iformean2$PlotThreshedGrainKgHa)

#plot year 3 NOT adjusted
NdZSI$predicted <- predict(modNZG1, newdata = NdZSI, re.form = NA)
ggplot(NdZSI, aes(x = N, y = G, color = CROP, group= CROP)) +
    geom_point() + 
  geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values
  labs(x = "N-Rate (Kg/ha)", y = "Grain Yield (Kg/ha)") +  # Label the axes
  ggtitle("Relationship between Grain Yield and Nrate") +  # Add a title
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
  ylim(0, 150) +
  facet_wrap(~P, scales = "free_y",ncol=2)+ #make it by location (remove to make it across locations)
  scale_color_discrete(name = "Cropping System")  #legend for colors
# save grain_Nrate_yr3

#three way emmeans to compare ranks of adjusted and unadjusted
N_levels <- c(0, 40, 80, 120, 160)
emmsNGNPC2 <- emmeans(modNZG1, specs= ~ N*P*CROP, at= list(N = N_levels), type= "response")
cld_dataNZGNPC <- cld(emmsNGNPC2, Letters=custom_letters)
#emmsNGadjNPC2 <- emmeans(modNZGadj1, specs= ~ N*P*CROP, at= list(N = N_levels), type= "response")
#cld_dataNZGadjNPC <- cld(emmsNGadjNPC2, Letters=custom_letters)
cld_dataNZGNPC
#cld_dataNZGadjNPC

### STOPPED HERE Aug 3

#Pairwise done based on adjusted year 2 values!!!
#Pairwise P:C
emmsPC <- emmeans(modNZG1, ~ P*CROP, type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNZGPC <- cld(emmsPC, Letters=custom_letters) # Create compact letter display
print(cld_dataNZGPC) # Print or view the compact letter display table
cld_dataNZGPC$response <- format(cld_dataNZGPC$response, digits = 5)
rownames(cld_dataNZGPC) <- NULL
cld_dataNZGPC<- cld_dataNZGPC %>%
  select(P, CROP, response, .group)
colnames(cld_dataNZGPC) <- c("Site","Cropping System","Grain Yield (kg ha-1)", "Group")
cld_dataNZGPC  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise N:P
N_levels <- c(0, 40, 80, 120, 160)
emmsNP <- emmeans(modNZG1, ~ N*P,at= list(N = N_levels), type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNZGNP <- cld(emmsNP, Letters=custom_letters) # Create compact letter display
print(cld_dataNZGNP) # Print or view the compact letter display table
cld_dataNZGNP$response <- format(cld_dataNZGNP$response, digits = 5)
rownames(cld_dataNZGNP) <- NULL
cld_dataNZGNP<- cld_dataNZGNP %>%
  select(N,P, response, .group)
colnames(cld_dataNZGNP) <- c("N","Site","Grain Yield (kg ha-1)", "Group")
cld_dataNZGNP  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise P
emmsP <- emmeans(modNZG1, ~ P,type= "response") # Obtain estimated marginal means (excluding N)
cld_dataNYGadjP <- cld(emmsP, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjP) # Print or view the compact letter display table
#Pairwise N
N_levels <- c(0, 40, 80, 120, 160)
emmsCYGadj <- emmeans(modNZG1, specs= ~ N, at= list(N = N_levels), type= "response" ) # Obtain estimated marginal means (excluding N)
cld_dataNYGadjC <- cld(emmsCYGadj, Letters=custom_letters) # Create compact letter display
print(cld_dataNYGadjC) # Print or view the compact letter display table


#This gives us the slope for each interactions as well as a P value indicating significance level for that slope
#emtrends(modNYGadj1,~ P*C, var= "N", infer=TRUE)
emtrends(modNZG1,~ P, var= "N", infer=TRUE)
#emtrends(modNYGadj1,~ C, var= "N", infer=TRUE)
summary(modNZG1)

emtrends_result<-emtrends(modNZG1,~ P, var= "N", infer=TRUE)
  emtrends_df <- as.data.frame(emtrends_result)
  desired_order_P <- c("MN", "NY", "KS", "WI")
  emtrends_df$P <- factor(emtrends_df$P, levels = desired_order_P)
emmeans_results<-emmeans(modNZG1, ~P, at=list(N=0))
emmeans_df <- as.data.frame(emmeans_results)
merged_df <- emtrends_df %>%
  inner_join(emmeans_df, by = c("P")) %>%
  select(P, emmean, N.trend, SE.x)
#view(merged_df)
merged_df$P <- factor(merged_df$P, levels = c("MN", "NY", "KS", "WI"))  # Preferred order for P
# Create a new data frame with the calculated column
new_df <- merged_df %>%
  mutate(equation = sprintf("=%.2f*e(%.4fN)", exp(emmean), N.trend),  SE.x = sprintf("%.4f", SE.x),  percent_change = sprintf("%.2f%%", (exp(N.trend) - 1) * 100))%>%
  select(-emmean, -N.trend)
sorted_df <- new_df %>%
  arrange(P)
view(sorted_df)
#write.csv(sorted_df, "data/Nrate_esteff_grain_yr3.csv")
```

# Grain anovas Table 

```{r}
my_modelsNG <- c(modNXG1, modNYG1, modNYGadj1)
anovasNG <- purrr::map(my_modelsNG, ~anova(.))
names(anovasNG) <- c("Year 1", "Year 2 (unadjusted)",  "Year 2 (adjusted with year 1 data)")


# Function to format p-values as stars
format_p_value <- function(p_val) {
  stars <- ifelse(p_val < 0.001, "***", ifelse(p_val < 0.01, "**", ifelse(p_val < 0.05, "*", "")))
  return(stars)
}

# Apply the function to your ANOVA results
NG_stars_tibble <- map(anovasNG, as_tibble, rownames="term") %>%
  bind_rows(.id = "model") %>%
  mutate(stars = map_chr(`Pr(>F)`, format_p_value))

NG_stars_tibble <- NG_stars_tibble %>%
  mutate(term = ifelse(term == "P", "E", term)) %>%
  mutate(term = ifelse(term == "N:P", "N:E", term))%>%
  mutate(term = ifelse(term == "P:C", "E:C", term))%>%
  mutate(term = ifelse(term == "N:P:C", "N:E:C", term))

# Print the tibble
print(NG_stars_tibble)

NG_stars <-NG_stars_tibble |> 
  select(model, term, stars) |>
  pivot_wider(names_from = term, values_from = stars)

gt_NG <- gt(NG_stars)

gt_NG |> gtsave("gt_NG.png", expand = 10)
```

# grain figures redo N:E
```{r}
#N:E
# Layer all the plots together!
colors <- c("Year 1 Summer Harvest" = "red", 
            "Year 1 Fall Harvest" = "green", 
            "Year 2 Summer Harvest" = "blue", 
            "Year 2 Fall Harvest" = "purple")
legend_order2 <- c("Year 1 Summer Harvest", 
                  "Year 2 Summer Harvest")
# Define the desired order of 'P'
desired_order <- c("MN", "NY", "KS", "WI")
NdXSIG$P <- factor(NdXSIG$P, levels = desired_order)

GraincomboplotNE <- ggplot(data=NdXSIG) +
  geom_point(data = NdXSIG, aes(x = N, y = G, color = "Year 1 Summer Harvest", shape = C)) +
  geom_point(data = DATA32, aes(x = N, y = GAdjY, color = "Year 2 Summer Harvest", shape = C)) +
  labs(x = "N-Rate (Kg ha-1)", y = "Grain Yield", linetype = "Cropping System", shape = "Cropping System", color = "Harvest")+
  scale_x_continuous(breaks = c(0, 40, 80, 120, 160)) +
  ylim(0, 1550) +
  facet_wrap(~P, scales = "free_y", ncol = 2) +
  scale_shape_manual(values = c(4, 25),labels = c("Intercropped","Monoculture IWG"))+
    scale_color_manual(values = colors, limits = legend_order2)+
  geom_function(data=subset(NdXSIG, P== "MN"), fun=~179.38*exp(0.0021*.x),color='red')+
  geom_function(data=subset(NdXSIG, P== "NY"), fun=~408.24*exp(0.0047*.x),color='red')+
  geom_function(data=subset(NdXSIG, P== "KS"), fun=~407.18*exp(-0.0002*.x),color='red')+
  geom_function(data=subset(NdXSIG, P== "WI"), fun=~736.77*exp(-0.0001*.x),color='red')+
  geom_function(data=subset(DATA32, P== "NY"), fun=~222.27*exp(0.0009*.x),color='blue')+
  geom_function(data=subset(DATA32, P== "KS"), fun=~99.20*exp(0.0005*.x),color='blue')+
  geom_function(data=subset(DATA32, P== "WI"), fun=~278.01*exp(0.0065*.x),color='blue')
print(GraincomboplotNE)

ggsave("GraincomboplotNE.jpg", plot = GraincomboplotNE, width = 8, height = 6, dpi = 300)


```

# grain figure E:C (X)
```{r}

NXGemmsPC <- emmeans(modNXG1, ~ P*C, type = "response") # Obtain estimated marginal means (excluding N)
emms_df <- as.data.frame(NXGemmsPC)
cld_dataNXGPC <- cld(NXGemmsPC, Letters=custom_letters)
cld_df <-as.data.frame(cld_dataNXGPC)
merged_df <- merge(emms_df, cld_df,by = c("P", "C"))
custom_labels <- c("Intercrop", "Monoculture IWG")
custom_colors <- c("darkmagenta", "cyan") 
GXPC<-ggplot(NdXSIG, aes(x = P, y = exp(predicted), color = C)) +
  geom_jitter(width = 0.2, height = 0, size = 3, alpha = 0.7) +
  labs(x = "Environment", y = "Grain Yield") +
  geom_point(data = emms_df, aes(x = P, y = response), 
             size = 4, shape = 18, color = "black")+ 
  geom_errorbar(data = emms_df, aes(x = P, ymin = lower.CL, ymax = upper.CL), 
                width = 0.2, color = "black", inherit.aes = FALSE) +
  geom_text(data = merged_df, aes(x = P, y = response.x, label = .group), 
            color = "black", vjust = 0, hjust = 1.8)+
  scale_color_manual(name = "Cropping System", labels = custom_labels,values = custom_colors)+
    guides(color = "none")+
     ggtitle("Year 1")+
  theme(plot.title = element_text(hjust = 0.5))
print(GXPC)
ggsave("GXPC.jpg", plot = GXPC, width = 8, height = 6, dpi = 300)
```

# grain figure E:C (Y)
```{r}

NYGemmsPC <- emmeans(modNYGadj1, ~ P*C, type = "response") # Obtain estimated marginal means (excluding N)
emms_df <- as.data.frame(NYGemmsPC)
cld_dataNYGPC <- cld(NYGemmsPC, Letters=custom_letters)
cld_df <-as.data.frame(cld_dataNYGPC)
merged_df <- merge(emms_df, cld_df,by = c("P", "C"))
custom_labels <- c("Intercrop", "Monoculture IWG")
custom_colors <- c("darkmagenta", "cyan") 
GYPC<-ggplot(DATA32, aes(x = P, y = exp(predicted), color = C)) +
  geom_jitter(width = 0.2, height = 0, size = 3, alpha = 0.7) +
  labs(x = "Environment", y = "Grain Yield") +
  geom_point(data = emms_df, aes(x = P, y = response), 
             size = 4, shape = 18, color = "black")+ 
  geom_errorbar(data = emms_df, aes(x = P, ymin = lower.CL, ymax = upper.CL), 
                width = 0.2, color = "black", inherit.aes = FALSE) +
  geom_text(data = merged_df, aes(x = P, y = response.x, label = .group), 
            color = "black", vjust = 0, hjust = 3)+
  scale_color_manual(name = "Cropping System", labels = custom_labels,values = custom_colors)+
     ggtitle("Year 2")+
  theme(plot.title = element_text(hjust = 0.5))+
    scale_y_continuous(breaks = c(250, 500, 750, 1000, 1250), limits = c(0, 1260))


print(GYPC)
ggsave("GYPC.jpg", plot = GYPC, width = 8, height = 6, dpi = 300)
```

# combined grain year 1 and 2 plots E:C
# Probably need to add in yr 3 ! 
```{r}
GEC<-grid.arrange(GXPC, GYPC, ncol = 2)
ggsave("GEC.jpg", plot = GEC, width =12, height = 6, dpi = 350)
```





***
Grain PLER NEED TO UPDATE ALL OF THIS 

#GPLER year 1 math (missing NY rep 2 for some reason but i dont think I can be bothered... I THINK ITS BECAUSE YOU took out 208...)
```{r}
#0 
NdSW0GLER <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW0 = (G[Treatment == 10]) / (G[Treatment == 5])
  )
NdSW0GLER<-NdSW0GLER[NdSW0GLER$Harvest == "Summer",]
print(NdSW0GLER)

#40
NdSW40GLER <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW40 = (G[Treatment == 11]) / (G[Treatment == 6])
  )
NdSW40GLER<-NdSW40GLER[NdSW40GLER$Harvest == "Summer",]
print(NdSW40GLER)

#80
NdSW80GLER <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW80 = (G[Treatment == 12]) / (G[Treatment == 7])
  )
NdSW80GLER<-NdSW80GLER[NdSW80GLER$Harvest == "Summer",]
print(NdSW80GLER)

#120
NdSW120GLER <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW120 = (G[Treatment == 13]) / (G[Treatment == 8])
  )
NdSW120GLER<-NdSW120GLER[NdSW120GLER$Harvest == "Summer",]
print(NdSW120GLER)

#160
NdSW160GLER <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW160= (G[Treatment == 14]) / (G[Treatment == 9])
  )
NdSW160GLER<-NdSW160GLER[NdSW160GLER$Harvest == "Summer",]
print(NdSW160GLER)

#merge dataframes 
GLER1<-left_join(NdSW0GLER, NdSW40GLER, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER1)
GLER2<-left_join(GLER1, NdSW80GLER, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER2)
GLER3<-left_join(GLER2, NdSW120GLER, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER3)
GLER4<-left_join(GLER3, NdSW160GLER, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER4)

#rearrange dataframe 
GLER4 <- GLER4 %>%
  pivot_longer(cols = starts_with("PartialLER") | starts_with("TotalLER"),
               names_to = "Nrate",
               values_to = "LER")

#cut off total and partial 
GLER4$Type <- sub("^(Partial|Total)", "", GLER4$Nrate)
GLER4$tot_or_part <- sub("^(Partial|Total).*", "\\1", GLER4$Nrate)
print(GLER4)

#cut off LERIWGSW and LERAlfSW and LERSW
GLER4$NRATE <- sub("^(LERGSW|LERAlfSW|LERSW)", "", GLER4$Type)
GLER4$PlotType <- sub("^(LERGSW|LERAlfSW|LERSW).*", "\\1", GLER4$Type)
print(GLER4)
GLER4$N<-as.numeric(GLER4$NRATE)

#get rid of pesky NA results (caused by missing plots inherent in year 1 KS summer data)
GLERX<- na.omit(GLER4)
print(GLERX)
```

#Grain PLER year 1 model (use PLER to see if there is interaction between Cropping system and Nrate and yield)
```{r}
NdXSIG
GLERX$P<-as.factor(GLERX$P)
as.numeric(GLERX$N)
as.numeric(GLERX$LER)
#linear
modGPLERX<-lmer(LER~N*P + (1|Rep), data= GLERX)
anova(modGPLERX)
#check assumptions
GPLERX_resid<-resid(modGPLERX)
qqnorm(GPLERX_resid)
qqline(GPLERX_resid)
plot(modGPLERX)
#Logtransform
modGPLERX1<-lmer(log(LER)~N*P + (1|Rep), data=GLERX)
anova(modGPLERX1)
#check assumptions logtransform (makes BETTER!)
GPLERX_resid1<-resid(modGPLERX1)
qqnorm(GPLERX_resid1)
qqline(GPLERX_resid1)
plot(modGPLERX1)

#Comparison plots

# Boxplot for I Partial LER
ggplot(GLERX, aes(x = P, y = LER, fill = as.factor(N))) +
  geom_boxplot() +
  labs(title = "Year 1 Grain Partial LER by Location and N Rate", x = "Location", y = "Grain Partial LER")+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")

max(GLERX$LER)
#plots
GLERX$predicted <- predict(modGPLERX1, newdata = GLERX, re.form = NA)
ggplot(GLERX, aes(x = N, y = LER)) +
    geom_point() + geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values
  labs(x = "N-Rate (Kg/ha)", y = "Grain Partial LER (Kg/ha)") +  # Label the axes
  ggtitle("Relationship between Year 1 Grain Partial LER and N-rate") +  # Add a title
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
  ylim(0, 7.1) +
  facet_wrap(~P, scales = "free_y",ncol=2)+ #make it by location (remove to make it across locations)
  scale_color_discrete(name = "Cropping System")+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")#legend for colors

#TWO way emmeans
GPLERX1emm <- compute_emmeansNXS2("modGPLERX1")

#Pairwise comparison P 
emmsNGPLERP <- emmeans(modGPLERX1, specs= ~ P,  type= "response")
cld_dataNGPLERX1P <- cld(emmsNGPLERP, Letters=custom_letters)
cld_dataNGPLERX1P $response <- format(cld_dataNGPLERX1P $response, digits = 2)
cld_dataNGPLERX1P $lower.CL <- format(cld_dataNGPLERX1P $lower.CL, digits = 2)
cld_dataNGPLERX1P $upper.CL <- format(cld_dataNGPLERX1P $upper.CL, digits = 3)
rownames(cld_dataNGPLERX1P ) <- NULL
cld_dataNGPLERX1P<- cld_dataNGPLERX1P  %>%
  select( P, response,lower.CL, upper.CL, .group)
colnames(cld_dataNGPLERX1P ) <- c( "Site", "GPLER","l","h", "Group")
cld_dataNGPLERX1P  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)

#Pairwise comparison N 
N_levels <- c(0, 40, 80, 120, 160)
emmsNGPLERN <- emmeans(modGPLERX1, specs= ~ N, at= list(N = N_levels), type= "response")
cld_dataNGPLERX1N <- cld(emmsNGPLERN, Letters=custom_letters)
cld_dataNGPLERX1N $response <- format(cld_dataNGPLERX1N $response, digits = 2)
cld_dataNGPLERX1N $lower.CL <- format(cld_dataNGPLERX1N $lower.CL, digits = 2)
cld_dataNGPLERX1N $upper.CL <- format(cld_dataNGPLERX1N $upper.CL, digits = 3)
rownames(cld_dataNGPLERX1N ) <- NULL
cld_dataNGPLERX1N <- cld_dataNGPLERX1N  %>%
  select( N, response,lower.CL, upper.CL, .group)
colnames(cld_dataNGPLERX1N ) <- c( "N", "APLER","l","h", "Group")
cld_dataNGPLERX1N  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)

```

#GPLER year 2 math (why is rep 2 also missing from year 2? oh because adjusted is made from year 1 and 208 was missing from the beginning of all this analysis for year 1 etc etc etc... ugh. I'm not going to fix it unless it becomes a problem.)
```{r}
#0 
NdSW0GLERY <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW0 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 5])
  )

#40
NdSW40GLERY <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW40 = (GAdjY[Treatment == 11]) / (GAdjY[Treatment == 6])
  )

#80
NdSW80GLERY <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW80 = (GAdjY[Treatment == 12]) / (GAdjY[Treatment == 7])
  )

#120
NdSW120GLERY <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW120 = (GAdjY[Treatment == 13]) / (GAdjY[Treatment == 8])
  )

#160
NdSW160GLERY <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    PartialLERGSW160= (GAdjY[Treatment == 14]) / (GAdjY[Treatment == 9])
  )

#merge dataframes 
GLER1<-left_join(NdSW0GLERY, NdSW40GLERY, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER1)
GLER2<-left_join(GLER1, NdSW80GLERY, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER2)
GLER3<-left_join(GLER2, NdSW120GLERY, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER3)
GLER4<-left_join(GLER3, NdSW160GLERY, by = c("Rep", "P", "YearCode", "Harvest"))
print(GLER4)

#rearrange dataframe 
GLER4 <- GLER4 %>%
  pivot_longer(cols = starts_with("PartialLER") | starts_with("TotalLER"),
               names_to = "Nrate",
               values_to = "LER")

#cut off total and partial 
GLER4$Type <- sub("^(Partial|Total)", "", GLER4$Nrate)
GLER4$tot_or_part <- sub("^(Partial|Total).*", "\\1", GLER4$Nrate)
print(GLER4)

#cut off LERIWGSW and LERAlfSW and LERSW
GLER4$NRATE <- sub("^(LERGSW|LERAlfSW|LERSW)", "", GLER4$Type)
GLER4$PlotType <- sub("^(LERGSW|LERAlfSW|LERSW).*", "\\1", GLER4$Type)
print(GLER4)
GLER4$N<-as.numeric(GLER4$NRATE)

#get rid of pesky NA results (caused by missing plots inherent in year 1 KS summer data)
GLERY<- na.omit(GLER4)
print(GLERY)
```

#Grain PLER year 2 model 
```{r}
GLERY$P<-as.factor(GLERY$P)
as.numeric(GLERY$N)
as.numeric(GLERY$LER)
#linear
modGPLERY<-lmer(LER~N*P + (1|Rep), data= GLERY)
anova(modGPLERY)
#check assumptions
GPLERY_resid<-resid(modGPLERY)
qqnorm(GPLERY_resid)
qqline(GPLERY_resid)
plot(modGPLERY)
#Logtransform
modGPLERY1<-lmer(log(LER)~N*P + (1|Rep), data=GLERY)
anova(modGPLERY1)
#check assumptions logtransform (makes BETTER!)
GPLERY_resid1<-resid(modGPLERY1)
qqnorm(GPLERY_resid1)
qqline(GPLERY_resid1)
plot(modGPLERY1)

#Comparison plots

# Boxplot for I Partial LER
ggplot(GLERY, aes(x = P, y = LER, fill = as.factor(N))) +
  geom_boxplot() +
  labs(title = "Year 2 Grain Partial LER by Location and N Rate", x = "Location", y = "Grain Partial LER")

max(GLERY$LER)
#plots
GLERY$predicted <- predict(modGPLERY1, newdata = GLERY, re.form = NA)
ggplot(GLERY, aes(x = N, y = LER)) +
    geom_point() + geom_line(aes(N, exp(predicted)))+ #regression through backtransformed predicted values
  labs(x = "N-Rate (Kg/ha)", y = "Grain Partial LER (Kg/ha)") +  # Label the axes
  ggtitle("Relationship between year 2 Grain Partial LER and N-rate") +  # Add a title
scale_x_continuous(breaks = c(0, 40, 80, 120, 160))+ #fix x axis scale
  ylim(0, 7.1) +
  facet_wrap(~P, scales = "free_y",ncol=2)+ #make it by location (remove to make it across locations)
  scale_color_discrete(name = "Cropping System")+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")#legend for colors

#Pairwise P
emmsP <- emmeans(modGPLERY1, specs = ~ P, type = "response")
cld_dataNGPLERYP <- cld(emmsP) # Create compact letter display
cld_dataNGPLERYP $response <- format(cld_dataNGPLERYP $response, digits = 2)
cld_dataNGPLERYP $lower.CL <- format(cld_dataNGPLERYP $lower.CL, digits = 2)
cld_dataNGPLERYP $upper.CL <- format(cld_dataNGPLERYP $upper.CL, digits = 3)
rownames(cld_dataNGPLERYP ) <- NULL
cld_dataNGPLERYP <- cld_dataNGPLERYP  %>%
  select( P, response,lower.CL, upper.CL, .group)
colnames(cld_dataNGPLERYP ) <- c( "Site", "APLER","l","h", "Group")
cld_dataNGPLERYP  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise comparison N 
N_levels <- c(0, 40, 80, 120, 160)
emmsNGPLERN <- emmeans(modGPLERY1, specs= ~ N, at= list(N = N_levels), type= "response")
cld_dataNGPLERY1N <- cld(emmsNGPLERN, Letters=custom_letters)
cld_dataNGPLERY1N $response <- format(cld_dataNGPLERY1N $response, digits = 2)
cld_dataNGPLERY1N $lower.CL <- format(cld_dataNGPLERY1N $lower.CL, digits = 2)
cld_dataNGPLERY1N $upper.CL <- format(cld_dataNGPLERY1N $upper.CL, digits = 3)
rownames(cld_dataNGPLERY1N ) <- NULL
cld_dataNGPLERY1N <- cld_dataNGPLERY1N  %>%
  select( N, response,lower.CL, upper.CL, .group)
colnames(cld_dataNGPLERY1N ) <- c( "N", "APLER","l","h", "Group")
cld_dataNGPLERY1N  |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
```

#Grain PLER combo plot
```{r}
# Layer all the plots together!
colors <- c("Year 1 Summer Harvest" = "red", 
            "Year 1 Fall Harvest" = "green", 
            "Year 2 Summer Harvest" = "blue", 
            "Year 2 Fall Harvest" = "purple")
legend_order2 <- c("Year 1 Summer Harvest", 
                  "Year 2 Summer Harvest")
GLERX$P <- factor(GLERX$P, levels = desired_order)
max(GLERX$LER)
max(GLERY$LER)
GPLERcomboplot <- ggplot() +
  geom_line(data = GLERX, aes(N, exp(predicted), color = "Year 1 Summer Harvest")) +
  geom_point(data =GLERX, aes(x = N, y = LER, color = "Year 1 Summer Harvest")) +
  geom_line(data = GLERY, aes(N, exp(predicted), color = "Year 2 Summer Harvest")) +
  geom_point(data = GLERY, aes(x = N, y = LER, color = "Year 2 Summer Harvest")) +
  labs(x = "N-Rate (kg ha-1)", y = "Grain PLER",
    color = "Harvest", 
    linetype = "Cropping System", shape = "Cropping System") +
  ggtitle("Relationship Between Grain PLER and N-rate") +
  scale_x_continuous(breaks = c(0, 40, 80, 120, 160)) +
  ylim(0, 7.1) +
  facet_wrap(~P, scales = "free", ncol = 2) +
  scale_color_manual(values = colors, limits = legend_order2)+
  scale_shape_manual(values = c(4, 20))+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")


print(GPLERcomboplot)

ggsave("GPLERcomboplot.jpg", plot = GPLERcomboplot, width = 8, height = 6, dpi = 300)
```
***
Nrate Relative yield stuff

#GPLER E plot (Y)
```{r}
NGLERYemmsP <- emmeans(modGPLERY1, ~ P, type = "response") 
emms_df <- as.data.frame(NGLERYemmsP)
cld_dataNGLERYP <- cld(NGLERYemmsP, Letters=custom_letters)
cld_df <-as.data.frame(cld_dataNGLERYP)
merged_df <- merge(emms_df, cld_df,by = c("P"))
GLERE<-ggplot(GLERY, aes(x = P, y = exp(predicted))) +
  geom_jitter(width = 0.2, height = 0, size = 3, alpha = 0.7, color="darkgreen") +
  labs(x = "Environment", y = "Grain PLER") +
  geom_point(data = emms_df, aes(x = P, y = response), 
             size = 4, shape = 18, color = "black")+ 
  geom_errorbar(data = emms_df, aes(x = P, ymin = lower.CL, ymax = upper.CL), 
                width = 0.2, color = "black", inherit.aes = FALSE) +
  geom_text(data = merged_df, aes(x = P, y = response.x, label = .group), 
            color = "black", vjust = 0, hjust = 1.8)

print(GLERE)
ggsave("GLERE.jpg", plot = GLERE, width = 8, height = 6, dpi = 300)
```

#Grain year 1 relative yields
```{r}
#0
NGRY0 <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield0 = (G[Treatment == 10]) / (G[Treatment == 5]))
#40
NGRY40 <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield40 = (G[Treatment == 10]) / (G[Treatment == 6]))
#80
NGRY80 <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield80 = (G[Treatment == 10]) / (G[Treatment == 7]))
#120
NGRY120 <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield120 = (G[Treatment == 10]) / (G[Treatment == 8]))
#160
NGRY160 <- NdXSIG %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield160 = (G[Treatment == 10]) / (G[Treatment == 9]))
#Join together all the tables
NGRY<-left_join(NGRY0, NGRY40, by = c("Rep", "P", "YearCode", "Harvest"))
NGRY<-left_join(NGRY, NGRY80, by = c("Rep", "P", "YearCode", "Harvest"))
NGRY<-left_join(NGRY, NGRY120, by = c("Rep", "P", "YearCode", "Harvest"))
NGRY<-left_join(NGRY, NGRY160, by = c("Rep", "P", "YearCode", "Harvest"))
print(NGRY)

# Reshape the data from wide to long format
NGRY_long <- NGRY %>%
  pivot_longer(cols = starts_with("GRelativeYield"),
               names_to = "N_rate",
               values_to = "GRelativeYield") %>%
  separate(N_rate, into = c("N_rate", "N"), sep = "GRelativeYield") %>%
  mutate(N = as.numeric(N))

#models 
#year 1 grain RY
modGRYX<-lmer(GRelativeYield~N*P + (1|Rep), data=NGRY_long)
anova(modGRYX)
#check assumptions 
GRYX_resid<-resid(modGRYX)
qqnorm(GRYX_resid)
qqline(GRYX_resid)
plot(modGRYX)
#Logtransform
modGRYX1<-lmer(log(GRelativeYield)~N*P + (1|Rep), data=NGRY_long)
anova(modGRYX1)
#check LOG assumptions 
GRYX_resid1<-resid(modGRYX1)
qqnorm(GRYX_resid1)
qqline(GRYX_resid1)
plot(modGRYX1)

# Create box plots: 
# Define the order of factor levels and Convert N to a factor with specified levels
factor_levels <- c("0", "40", "80", "120", "160")
NGRY_long$N <- factor(NGRY_long$N, levels = factor_levels)
NGRY_long$P <- factor(NGRY_long$P, levels = desired_order)
GRYXcomboplot<-ggplot(NGRY_long, aes(x = N, y = GRelativeYield)) +
  geom_boxplot() +
  facet_wrap(~P, scales = "free_y",ncol=2) +
  labs(x = "N Rate", y = "Relative Yield") +
  theme_minimal()+
  scale_x_discrete(breaks = c(0, 40, 80, 120, 160))+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")+
  ggtitle("Year 1 Grain Relative Yield")+
    coord_cartesian(ylim = c(NA, NA))
ggsave("GRYXcomboplot.jpg", plot = GRYXcomboplot, width = 8, height = 6, dpi = 300)

#Pairwise comparisons
#Pairwise N
N_levels <- c(0, 40, 80, 120, 160)
emmsN <- emmeans(modGRYX1, specs = ~ N, at = list(N = N_levels), type = "response")
cld_dataGRYXN <- cld(emmsN) # Create compact letter display
cld_dataGRYXN  $response <- format(cld_dataGRYXN  $response, digits = 3)
cld_dataGRYXN $lower.CL <- format(cld_dataGRYXN $lower.CL, digits = 3)
cld_dataGRYXN $upper.CL <- format(cld_dataGRYXN $upper.CL, digits = 3)
rownames(cld_dataGRYXN  ) <- NULL
cld_dataGRYXN  <- cld_dataGRYXN   %>%
  select( N, response, lower.CL, upper.CL, .group)
colnames(cld_dataGRYXN  ) <- c( "N", "TLER","l","h", "Group")
cld_dataGRYXN    |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise P
emmsP <- emmeans(modGRYX1, specs = ~ P, type = "response")
cld_dataGRYXP <- cld(emmsP) # Create compact letter display
cld_dataGRYXP  $response <- format(cld_dataGRYXP  $response, digits = 3)
cld_dataGRYXP $lower.CL <- format(cld_dataGRYXP $lower.CL, digits = 3)
cld_dataGRYXP $upper.CL <- format(cld_dataGRYXP $upper.CL, digits = 3)
rownames(cld_dataGRYXP  ) <- NULL
cld_dataGRYXP  <- cld_dataGRYXP   %>%
  select( P, response, lower.CL, upper.CL, .group)
colnames(cld_dataGRYXP  ) <- c( "Site", "GRY","l","h", "Group")
cld_dataGRYXP    |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
```

#Grain year 2 relative yields
```{r}
#0
NYGRY0 <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield0 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 5]))
#40
NYGRY40 <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield40 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 6]))
#80
NYGRY80 <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield80 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 7]))
#120
NYGRY120 <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield120 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 8]))
#160
NYGRY160 <- DATA32 %>%
  group_by(Rep, P, YearCode, Harvest) %>%
  reframe(
    GRelativeYield160 = (GAdjY[Treatment == 10]) / (GAdjY[Treatment == 9]))
#Join together all the tables
NYGRY<-left_join(NYGRY0, NYGRY40, by = c("Rep", "P", "YearCode", "Harvest"))
NYGRY<-left_join(NYGRY, NYGRY80, by = c("Rep", "P", "YearCode", "Harvest"))
NYGRY<-left_join(NYGRY, NYGRY120, by = c("Rep", "P", "YearCode", "Harvest"))
NYGRY<-left_join(NYGRY, NYGRY160, by = c("Rep", "P", "YearCode", "Harvest"))
print(NYGRY)

# Reshape the data from wide to long format
NGRY_longY <- NYGRY %>%
  pivot_longer(cols = starts_with("GRelativeYield"),
               names_to = "N_rate",
               values_to = "GRelativeYield") %>%
  separate(N_rate, into = c("N_rate", "N"), sep = "GRelativeYield") %>%
  mutate(N = as.numeric(N))

#models 
#year 1 grain RY
modGRYY<-lmer(GRelativeYield~N*P + (1|Rep), data=NGRY_longY)
anova(modGRYY)
#check assumptions 
GRYY_resid<-resid(modGRYY)
qqnorm(GRYY_resid)
qqline(GRYY_resid)
plot(modGRYY)
#Logtransform
modGRYY1<-lmer(log(GRelativeYield)~N*P + (1|Rep), data=NGRY_longY)
anova(modGRYY1)
#check LOG assumptions 
GRYY_resid1<-resid(modGRYY1)
qqnorm(GRYY_resid1)
qqline(GRYY_resid1)
plot(modGRYY1)

# Create box plots: 
# Define the order of factor levels and Convert N to a factor with specified levels
factor_levels <- c("0", "40", "80", "120", "160")
NGRY_longY$N <- factor(NGRY_longY$N, levels = factor_levels)
NGRY_longY$P<-factor(NGRY_longY$P, levels = desired_order)
GRYYcomboplot<-ggplot(NGRY_longY, aes(x = N, y = GRelativeYield)) +
  geom_boxplot() +
  facet_wrap(~P, scales = "free",ncol=2) +
  labs(x = "N Rate", y = "Relative Yield") +
  theme_minimal()+
  scale_x_discrete(breaks = c(0, 40, 80, 120, 160))+
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed")+
  ggtitle("Year 2 Grain Relative Yield")+
    coord_cartesian(ylim = c(NA, NA))

ggsave("GRYYcomboplot.jpg", plot = GRYYcomboplot, width = 8, height = 6, dpi = 300)

#Pairwise comparisons
#Pairwise N
N_levels <- c(0, 40, 80, 120, 160)
emmsN <- emmeans(modGRYY1, specs = ~ N, at = list(N = N_levels), type = "response")
cld_dataGRYYN <- cld(emmsN, Letters=custom_letters) # Create compact letter display
cld_dataGRYYN  $response <- format(cld_dataGRYYN  $response, digits = 3)
cld_dataGRYYN $lower.CL <- format(cld_dataGRYYN $lower.CL, digits = 3)
cld_dataGRYYN $upper.CL <- format(cld_dataGRYYN $upper.CL, digits = 3)
rownames(cld_dataGRYYN  ) <- NULL
cld_dataGRYYN  <- cld_dataGRYYN   %>%
  select( N, response, lower.CL, upper.CL, .group)
colnames(cld_dataGRYYN  ) <- c( "N", "TLER","l","h", "Group")
cld_dataGRYYN    |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
#Pairwise N:P
emmsNP <- emmeans(modGRYY1, specs = ~ N:P, at = list(N = N_levels), type = "response")
cld_dataGRYYNP <- cld(emmsNP, Letters=custom_letters) # Create compact letter display
cld_dataGRYYNP  $response <- format(cld_dataGRYYNP  $response, digits = 3)
cld_dataGRYYNP $lower.CL <- format(cld_dataGRYYNP $lower.CL, digits = 3)
cld_dataGRYYNP $upper.CL <- format(cld_dataGRYYNP $upper.CL, digits = 3)
rownames(cld_dataGRYYNP  ) <- NULL
cld_dataGRYYNP  <- cld_dataGRYYNP   %>%
  select( N, P, response, lower.CL, upper.CL, .group)
colnames(cld_dataGRYYNP  ) <- c( "N", "Site", "TLER","l","h", "Group")
cld_dataGRYYNP    |> 
  data.frame() |> 
  kbl(align = "c") |> 
  kable_paper(full_width = F) |> 
  column_spec(1, bold = T)
```

#combo GRY boxplot 
```{r}
# Combine the data frames and create a new column to distinguish the years
NGRY_longY$Year <- "Year 2"
NGRY_long$Year <- "Year 1"
combined_data <- rbind(NGRY_longY, NGRY_long)

colors3<-c("Year 1" = "red", 
            "Year 2" = "blue")
# Convert N to a factor for proper ordering on the x-axis
combined_data$N <- factor(combined_data$N, levels = c("0", "40", "80", "120", "160"))

# Plotting both boxplots together with dodge positioning
GRYcomboplot <- ggplot(combined_data, aes(x = N, y = GRelativeYield, fill = Year)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  labs(x = "N Rate", y = "Relative Yield") +
  scale_x_discrete(breaks = c("0", "40", "80", "120", "160")) +
  geom_abline(intercept = 0.5, slope = 0, color = "red", linetype = "dashed") +
  ggtitle("Grain Relative Yield") +
  scale_fill_manual(values = colors3)+
  theme_minimal()+
  facet_wrap(~P, scales = "free", ncol = 2)

# Display the combined plot
print(GRYcomboplot)

ggsave("GRYcomboplot .jpg", plot = GRYcomboplot , width = 8, height = 6, dpi = 300)
```
